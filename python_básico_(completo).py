# -*- coding: utf-8 -*-
"""Python Básico (Completo).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1SIZ93pwbG-I7hC-Osfx5L8btK9ILE0OM

# Python Básico

**OBJETIVOS**: Ensinar o básico da linguagem python para o curso

---

## Introdução

### Variáveis

Em qualquer linguagem de programação é crucial saber trabalhar com variáveis. Elas são estruturas cujo objetivo é armazenar informações temporárias do programa na memória RAM.

Em python, a sintaxe para se criar uma variável é simples:
"""

a = 1

"""Ao dizer a = 1, estamos falando: "Por favor, armazene o valor de 1 a variável cujo nome será 'a'". Desta forma o sinal '=' em Python é o sinal de atribuição.

Há, é claro, regras para se criar um nome de uma variável, sendo elas:
1. Não pode começar com um número
2. Não pode conter caracter especial (",", "´", "/", ...), mas pode ter acentos (á, é, í, ...) e "_"
3. Não pode ter espaços no nome
"""

12abc = 1

a b c = 1

/a = 1

a-b-c = 1

a_b_c = 1

"""Você ainda pode criar múltiplas variáveis numa mesma linha"""

a, b, c = 1, 2, 3

"""Nós podemos utilizar o console do jupyter para acompanhar os valores de variáveis e nós podemos substituir os valores das mesmas"""

a = 2

a

a = 1

a

"""As variáveis em Python possuem tipos. E nós veremos ao longo desse notebook os principais tipos utilizados. Mas de longe o tipo mais comum de variáveis que trabalhamos são as numéricas: Inteiras, Reais e Complexas"""

type(a)

"""**NOTA**: Em Python nós temos as "funções padrões da linguagem" que são expressões como o "type" acima que podem ser utilizados livremente. Note que a cor do texto muda e devemos ter cuidado para não dar nomes de variáveis que sejam nomes desses "nomes reservados"

---

### Inteiros

Inteiros são os tipos mais comuns de variáveis podendo ir de $-\infty$ a $+\infty$, mas que não são representados com casas decimais:

-100, -10, -3, -2, -1, 0, 1, 2, 3, ...
"""

a = 1
b = 2
c = -7
d = -10000000

"""---

### Operações

Números inteiros (e variáveis do python em geral) aceitam operações matemáticas

**Soma**
"""

1 + 1

a + b

c = a + b
c

c = c + b

c

c += b
c

"""**Subtração**"""

2 - 1

b - a

c -= 1
c

"""**Multiplicação**"""

2 * 3

a * b

c *= 2
c

"""**Divisão**"""

6 / 3

b / a

"""**Divisão inteira**

<img src="https://gracianotorrao.files.wordpress.com/2014/10/divisaoi.png" />
"""

17 // 2

17 / 2

b // a

17 % 2

b % a

"""**Exponencial**"""

2 ** 3

b ** a

"""Operações no python seguem a mesma ordem da matemática, e nós podemos utilizar parenteses para determinar a ordem das operações"""

1 + 2 * 3

(1 + 2) * 3

"""---

### Comentários

Uma parte primordial de todo código é a estrutura de comentários que nos permite explicar o que cada bloco de código está fazendo com linguagem humana, para que terceiros possam entender mais facilmente o que estamos escrevendo.

Python apresentar algumas sintaxes para escreve comentários

O #
"""

# isto é um comentário
# isto também é um comentário
a = 1 # haja comentário meu vingador

a = # mas isto já é estupidez 1

"""O ''' ou '''"""

"""Isto é um comentário"""
a = 1

"""
Este é um grande comentário de
múltiplas linhas vou até fazer
uma dissertação aqui
"""

'''
Mas eu não preciso me prender as """ não
ein!
'''

a = """Isso"""

"""---

### Print e Input

A função print é responsável por imprimir saídas no console de Python. Apesar de não ser muito utilizada dentro do contexto do jupyter essa função é muito usada em códigos tradicionais e na maioria dos ambientes de programação de produção.

Para utiliza-la é simples basta chamar
"""

print("Alguma coisa a ser impressa")

"""E o conteúdo entre "" será colocado no console. Além disso você pode imprimir dados específicos ou dividir suas impressões em vária pedaços utilizando a sintaxe de vírgula"""

a = 1
b = 2
print("O valor de a é", a)
print("O valor de b é", b)
print("O valor de a + b é", a + b)
print("Olá", "mundo", a, "cruel")

"""Por padrão a função print gerará separadores utilizando o " ", mas você pode especificar como separar as palavras usando o argumento sep"""

print("Olá", "mundo", a, "cruel", sep="/")

"""Os textos impressos ainda aceitam caracteres especiais que utilizam a sintaxe "\alguma letra"
"""

print("Olá\nMundo")

print("Olá\tMundo")

"""Nós também podemos incorporar os valores de variáveis dentro do texto a ser imprimido utilizado a sintaxe do %"""

print("O valor de a é %d" % a, "Não sei", sep="|")

print("O valor de a é %d\nO valor de b é %i\nO valor de a + b é %d" % (a, b, a + b))

print("O valor de a é %03d" % 7)

"""Além de exportar informação nós também podemos receber informação por meio da função input"""

input("me manda ai um número: ")

"""A função input retornará o valor digitado que pode ser armazenado numa variável"""

num = input("me manda ai um número: ")

num

"""Entretanto note que o console não fornece um valor inteiro como estamos acostumados, mas no lugar nos devolve um valor '1'. Para obter o nosso valor de interesse precisamos fazer uma conversão de tipo"""

num = int(input("me manda ai um número: "))

num

"""---

**Exercício 1**

Organize os numeros 2,3,4,5,10,12 para obter a saída 18
em uma única operação:

    x = 12*3
    x = x + 4
    x = x//10
    x = x*5
    x = x - 2
    print(x)
"""



#@title Resposta
x = (12 * 3 + 4) // 10 * 5 - 2
print(x)

"""**Exercício 2**

Escreva um Programa que imprime dois numeros de sua escolha
e que depois imprime a soma, a subtração, a multiplicação,
a divisão normal e a divisão inteira,
e o resto da divisão do maior pelo menor
(coloque na mensagem a palavra resto ao invez do símbolo %)

EXEMPLO DE SAÍDA:

x = 15; y = 10

    15 + 10 = 25
    15 - 10 = 5
    15 x 10 = 150
    15 / 10 = 1.5
    15 // 10 = 1
    15 resto 10 = 5

"""



#@title Resposta
x = int(input("Digite o valor de x: "))
y = int(input("Digite o valor de y: "))

print("x =", x, "\ny =", y)
print(x, "+", y, "=", x + y)
print(x, "-", y, "=", x - y)
print(x, "x", y, "=", x * y)
print(x, "/", y, "=", x / y)
print(x, "//", y, "=", x // y)
print(x, "resto", y, "=", x % y)

"""---

## Controladores de Fluxo

### Estruturas de Decisão

#### Variáveis Booleanas

Além das variáveis de tipo inteiro nós temos outros tipos como as variáveis booleanas que são representações de valores binários de Verdadeiro e Falso (True e False respectivamente)
"""

verdadeiro = True
falso = False

"""As variáveis booleanas são resultados de comparações entre diferentes valores que avaliam uma determinada expressão"""

a = 2
a > 1

"""Veja que o resultado da expressão a > 1 é um valor booleano nos dizendo que o valor de a, 2, é de fato maior do que 1. De forma análoga temos todas as expressões comparativas conhecidas"""

print("a maior que 1", a > 1)
print("a maior igual a 1", a >= 1)
print("a menor que 1", a < 1)
print("a menor igual a 1", a <= 1)
print("a igual a 1", a == 1)
print("a diferente de 1", a != 1)
print("a entre 1 e 2", 1 < a < 2)

"""Podemos também concatenar expressões utilizando os operadores lógico and, or e not

AND: Só é verdadeiro quando as duas expressões são verdadeiras
"""

a = 1
b = 2

print(a == 1 , b > 1, a == 1 and b > 1)
print(a > 1 , b > 1, a > 1 and b > 1)
print(a == 1 , b < 1, a == 1 and b < 1)
print(a > 1 , b < 1, a > 1 and b < 1)

"""OR: É verdadeiro quando uma das expressões é verdadeira"""

a = 1
b = 2

print(a == 1 , b > 1, a == 1 or b > 1)
print(a > 1 , b > 1, a > 1 or b > 1)
print(a == 1 , b < 1, a == 1 or b < 1)
print(a > 1 , b < 1, a > 1 or b < 1)

c = 1

a == 1 and (b > 1 or c > 1)

"""NOT: Inverte o resultado de uma comparação"""

not a == 1

not a > 1

not (a == 1 or b > 1)

"""#### If / Elif / Else

Booleanos sozinhos não adicionam muito aos nosso programas, mas estruturas de decisão sim, uma vez que as mesmas podem alterar o andamento do código e executar determinados blocos de acordo com as condições especificadas
"""

idade = int(input("Qual a sua idade? "))
if idade >= 18:
    print("Hora de encher a cara")
print("Fim")

idade = int(input("Qual a sua idade? "))
if idade >= 18:
    print("Hora de encher a cara")
else:
    print("Pra você só toddynho")
print("Fim")

idade = int(input("Qual a sua idade? "))
if idade >= 65:
    print("Dá pra pegar busão de graça")
elif idade >= 18:
    print("Hora de encher a cara")
else:
    print("Pra você só toddynho")
print("Fim")

idade = int(input("Qual a sua idade? "))
if idade >= 120:
    print("Você é bem idoso!!")
elif idade >= 65:
    print("Dá pra pegar busão de graça")
elif idade >= 18:
    print("Hora de encher a cara")
else:
    print("Pra você só toddynho")
print("Fim")

idade = int(input("Qual a sua idade? "))
if idade >= 65:
    print("Dá pra pegar busão de graça")

if idade >= 18:
    print("Hora de encher a cara")
else:
    print("Pra você só toddynho")
print("Fim")

"""---

**Exercício 3**

Faça um Programa para uma loja de tintas.

O programa deverá pedir o tamanho em metros quadrados da área a ser pintada.
Considere que a cobertura da tinta é de 1 litro para cada 6 metros quadrados
e que a tinta é vendida em latas de 18 litros, que custam R\\$ 80,00 ou
em galões de 4 litros, que custam R\\$ 25,00.

Informe ao usuário as quantidades de tinta a serem compradas e os respectivos
preços em 3 situações:
    comprar apenas latas de 18 litros;
    comprar apenas galões de 4 litros;
    misturar latas e galões, de forma que o preço seja o menor.
"""



#@title Resposta
# insira o valor da área aqui
area = int(input("Insira o valor da área: "))

# Vamos calcular o numero de litros necessários para pintar a casa
litros = area // 6
if area % 6 > 0:
    litros = litros + 1

print("Litros necessários:", litros, "\n")

print("1) comprar apenas latas de 18 litros")
latas = litros // 18
if litros % 18 > 0:
    latas = latas + 1

print("Serão necessárias", latas, "latas")
print("Obteremos", latas * 18, "litros")
print("Total: R$", latas * 80)

print("\n2)Comprar apenas galões de 4 litros")
galoes = litros//4
if litros % 4 > 0:
    galoes = galoes + 1

print("Serão necessárias", galoes, "galoes")
print("Obteremos", galoes * 4, "litros")
print("Total: R$", galoes * 25)

# Vamos pensar, o preço total por litro pago nas latas é 80/18 ~ 4.44 R$/L
# enquanto que para o gualão é 25/4 ~ 6.25 R$/L
# portanto é sempre mais vantajoso comprar o máximo de latas possíveis
# e o mínimo de galões, desde que o preço desses galoes não ultrapasse o preço
# de uma lata, isto é, o numero de galoes seja menor ou igual a 3 (R$ 75)
print("\n3)Misturar latas e galões, de forma que o preço seja o menor.")
latas = litros // 18
galoes = 0
litros_restantes = litros % 18

if litros_restantes <= 3 * 4:
    # Ou seja o numero de galoes necessarios seja menor do que três
    galoes = litros_restantes // 4
    if litros_restantes % 4 > 0:
        galoes += 1
else:
    latas += 1

print("Serão necessárias", latas, "latas")
print("Serão necessárias", galoes, "galoes")
print("Obteremos", latas * 18 + galoes * 4, "litros")
print("Total: R$", galoes * 25 + latas * 80)

"""---

### Estruturas de Repetição

Estruturas de repetição são cruciais em qualquer linguagem de programação porque permitem que determinados blocos de código sejam executados múltiplas vezes. É justamente esse tipo de estrutura que evita que tenhamos que escrever o mesmo código repetidas vezes para se atingir um determinado resultado

#### While

O bloco while é utilizado para executar um determinado bloco de código ENQUANTO (while em português) uma condição seja verdadeira
"""

a = 0
while a < 5:
    print(a)
    a += 1

"""É preciso ser muito cuidadoso, entretanto com laços infinitos, uma vez que seu programa travará caso você faça isso, entretanto é relativamente comum seu uso por exemplo em jogos ou em aps iterativos de uso contínuo"""

a = 0
while a < 5:
    print(a)

"""---

**Exercício 4**

Dizemos que um inteiro positivo n é perfeito se for igual à soma de
seus divisores positivos diferentes de n.

Exemplo: 6 é perfeito, pois 1+2+3 = 6.
       
Dado um inteiro positivo n, verificar se n é perfeito.
"""



#@title Resposta
n = int(input("Digite o valor de n: "))

cont, soma = 2, 1
while cont < n:
    if n % cont == 0:
        soma += cont
    cont += 1

if soma == n:
    print ("O número", n, "é perfeito")
else:
    print ("O número", n, "não é perfeito")

"""---

#### For

Laços for, diferente do while, percorrem uma lista de itens em particular combinados com a expressão in. Esses laços são muito usados com listas (que veremos mais a frente), mas também com objetos "range"
"""

for a in range(5):
    print(a)

# começo = 0 (inclusivo)
# fim = 5 (não inclusivo)
# passo = 1
for a in range(0, 5, 1):
    print(a)

for a in range(0, 5, 2):
    print(a)

for a in range(-5, 0, 1):
    print(a)

for a in range(5, 0, -1):
    print(a)

for a in range(1, 11):
    print(a)

"""---

**Exercício 5**

Sabe-se que um número da forma n^3 é igual a soma de n ímpares consecutivos.

Exemplo: 1^3= 1, 2^3= 3+5, 3^3= 7+9+11,  4^3= 13+15+17+19,...

Dado m, determine os ímpares consecutivos cuja soma é igual a n^3 para n
assumindo valores de 1 a m.
"""



#@title Resposta
m = int(input("Digite o valor de m: "))
for n in range(1, m+1):
    soma, inicio = 0, 1
    while soma != n*n*n:
        soma = 0
        for i in range(n):
            soma = soma + inicio + 2 * i
        inicio += 2

    inicio = inicio - 2
    print("%d*%d*%d = " % (n, n, n))
    for i in range(n):
        print("+", inicio + 2 * i)
    print("\n")

"""---

#### Break e Continue

As expressões break e continue são controladores de fluxo que permitem alterar como um determinado loop funciona
"""

for i in range(5):
    if i == 3:
        break
    print(i)

for i in range(5):
    if i == 3:
        continue
    print(i)

"""---

**Exercício 6**

Escreva o jogo do chute.


Nele, dado um número inteiro entre 1 e 100, você deve pedir
para o usuário advinhar o número que você escolheu

Para cada chute do usuário você deve imprimir uma dica, se
ele chutou baixo de mais ou alto demais

Uma vez que o usuário acerte o chute o programa imprime uma
mensagem e também o número de chutes que o usuário deu

OBS: Use o statement break

Exemplo:

    Tente advinhar o número que eu estou pensando
    Seu Chute: 50
    Você deve chutar mais alto!
    Seu Chute: 75
    Você deve chutar mais alto!
    Seu Chute: 87
    Você deve chutar mais alto!
    Seu Chute: 93
    Você deve chutar mais alto!
    Seu Chute: 97
    Você deve chutar mais baixo!
    Seu Chute: 95
    Parabens você acertou!!
    Você chutou 6 vezes
"""



#@title Resposta
num = 37

chutes = 0

print("Tente advinhar o número que eu estou pensando")

while True:
    chute = int(input("Seu Chute: "))
    chutes += 1
    if chute == num:
        break
    elif chute < num:
        print("Você deve chutar mais alto!")
    else:
        print("Você deve chutar mais baixo!")


print("Parabens você acertou!!")
print("Você chutou %i vezes"%chutes)

"""---

## Tipos de Variáveis

### Variáveis Numéricas

#### Reais

Números reais são iguais a números inteiros, exceto que possuem casas decimais representadas por .
"""

a = 1.1
b = 1.0
c = 2.
d = .27

type(b)

"""Podemos converter números reais para inteiros e vice-versa utilizando operações matemáticas, na qual, por padrão, sempre converteremos o resultado da operação para um valor real."""

1.1 * 2

4.3 // 3

"""As funções float e int.

É importante notar que a função int não arredonda o número real, ela apenas pega o valor da representação numérica inteira do número
"""

float(2)

float("2.4")

int(2.4)

int(2.6)

"""E a função round"""

round(2.6)

round(3.435678, 2)

"""Nas funções de print podemos formatar números inteiros"""

print("Numero real", 2.3)
print("Numero real %f" % 2.3)
print("Numero real %.2f" % 2.34567)

"""---

**Exercício 7**

Tendo como dados de entrada a altura e o sexo de uma pessoa, construa um algoritmo que calcule seu peso ideal, utilizando as seguintes fórmulas:

Para homens: (72.7*h) - 58

Para mulheres: (62.1*h) - 44.7 (h = altura)

Peça o peso da pessoa e informe se ela está dentro, acima ou abaixo do peso.
"""



#@title Resposta
altura = float(input("Digite a sua altura: "))
sexo = int(input("Digite o seu sexo(Masculino = 0/ Feminino = 1): "))
peso = float(input("Digite o seu peso: "))

if sexo == 0:
    peso_ideal = (72.7 * altura) - 58
else:
    peso_ideal = (62.1 * altura) - 44.7

if peso > peso_ideal:
    print("Você está acima do peso")
elif peso == peso_ideal:
    print("Você está no seu peso ideal")
else:
    print("Você está abaixo do peso")

"""---

#### Complexo

Python também possuí estruturas para representar números complexos utilizando o j para representar a parte imaginária de um número
"""

a = 1 + 2j
a

"""Podemos acessar as partes reais e complexas de um número de forma independente"""

a.real

a.imag

"""E até fazer operações númericas com essas partes"""

a.real + 2

a.imag + 3

a.real = a.real + 2

"""Assim como com o próprio número"""

a + (2 + 0j)

"""De forma análoga a int e float, temos também uma função "complex" que permite fazer a conversão em um número complexo"""

complex(5, 2)

complex(2.6)

"""---

### Variáveis de Coleção

Além das variáveis que observamos até aqui que representam uma entidade numérica, nós também temos variáveis que corresponde a uma coleção de objetos. Isto é, variáveis com múltiplos valores.

Essas variáveis são muito utilizadas quando precisamos armazenar grupos de informação específicos e tem múltiplicas aplicação nos ambientes de programação. Vamos ver as principais delas

---

#### Listas

Python inclui diversas estruturas de dados compostas, usadas para agrupar outros valores. A mais versátil é list (lista), que pode ser escrita como uma lista de valores (itens) separados por vírgula, entre colchetes. Os valores contidos na lista não precisam ser todos do mesmo tipo.
"""

lista = [0, 1, 2, 3, 4, 5]
lista

lista = [0, 2.4, 3 + 1j]
lista

"""As lista podem ser indexadas (subscritas), com o primeiro elemento como índice 0"""

lista = [10, 20, 30, 40, 50]
print(lista[0])
print(lista[4])
print(lista[2])

lista[5]

"""Índices também podem ser números negativos para iniciar a contagem pela direita:"""

print(lista[-1])
print(lista[-2])
print(lista[-5])

lista[-7]

"""Note que dado que -0 é o mesmo que 0, índices negativos começam em -1.

Além da indexação, o fatiamento também é permitido. Embora a indexação seja usada para obter elementos individuais, fatiar permite que você obtenha conjuntos de elementos:
"""

print(lista[0:2])
print(lista[2:5])
print(lista[:2])
print(lista[2:])

"""Os índices do fatiamento possuem padrões úteis; um primeiro índice omitido padrão é zero, um segundo índice omitido é por padrão o tamanho da lista sendo fatiada:"""

print(lista[0:5:2])
print(lista[-2:])
print(lista[0::2])
print(lista[::-1])

"""Observe como o início sempre está incluído, e o fim sempre é excluído. Isso garante que lista[:i] + lista[i:] seja sempre igual a lista:

"""

print(lista[:2] + lista[2:])
print(lista[:4] + lista[4:])

"""Uma maneira de lembrar como fatias funcionam é pensar que os índices indicam posições entre elementos, onde a borda esquerda do primeiro elemento é 0. Assim, a borda direita do último elemento de uma lista de comprimento n tem índice n, por exemplo:"""

print(
"""
 +---+---+---+---+---+---+
 | 0 | 1 | 2 | 3 | 4 | 5 |
 +---+---+---+---+---+---+
 0   1   2   3   4   5   6
-6  -5  -4  -3  -2  -1
"""
)

"""A primeira fileira de números indica a posição dos índices 0…6 na lista; a segunda fileira indica a posição dos respectivos índices negativos. Uma fatia de i a j consiste em todos os caracteres entre as bordas i e j, respectivamente.

Para índices positivos, o comprimento da fatia é a diferença entre os índices, se ambos estão dentro dos limites da lista. Por exemplo, o comprimento de lista[1:3] é 2.

A tentativa de usar um índice que seja muito grande resultará em um erro:
"""

lista[42]

"""No entanto, os índices de fatiamento fora do alcance são tratados graciosamente (N.d.T: o termo original “gracefully” indica robustez no tratamento de erros) quando usados para fatiamento. Um índice maior que o comprimento é trocado pelo comprimento, um limite superior menor que o limite inferior produz uma string vazia:"""

print(lista[2:42])
print(lista[42:])

"""O terceiro termo do fatiamento indica o passo a ser aplicado entre cada elemento"""

lista[0:5:1]

lista[0:5:2]

lista[-1:-4:-1]

"""Listas também podem ser combinadas entre si utilizando os operadores + e *"""

lista1 = [1, 2, 3]
lista2 = [4, 5, 6]
lista3 = lista1 + lista2
lista3

lista1 * 3

"""Listas também aceitam qualquer tipo de objeto incluindo outras listas"""

lista = [0, 2.4, 3 + 1j, [1, 2, 3]]
lista

lista[3][1]

"""Listas são objetos mútaveis na qual podemos alterar os valores de seus elementos utilizando a sintaxe de atribuição"""

lista = [1, 2, 3]
lista[2] = 4
lista

"""Além disso, elas possuem múltiplos métodos para alterar seu conteúdo (https://docs.python.org/3/tutorial/datastructures.html), abaixo listamos os mais comuns

APPEND: Adiciona um novo elemento ao final da lista
"""

lista = [1, 2, 3]
print(lista)
lista.append(4)
print(lista)
lista.append(5)
print(lista)

"""REMOVE: Remove a primeira ocorrência de um determinado elemento de uma lista"""

lista = [1, 2, 3]
print(lista)
lista.remove(3)
print(lista)

lista.remove(3)

lista = [1, 2, 3, 4, 5, 6, 3]
print(lista)
lista.remove(3)
print(lista)

"""INSERT: Insere um novo elemento no indice selecionado da lista"""

lista = [1, 2, 3]
print(lista)
lista.insert(1, 1.1)
print(lista)

"""SORT: Ordena os elementos da lista"""

lista = [1, 7, 4, 3, 9, 6]
print(lista)
lista.sort()
print(lista)

lista = [1, 7, 4, 3, [9, 6]]
print(lista)
lista.sort()
print(lista)

"""Assim como range, listas são objetos que podem ser percorridos com for loops"""

for i in lista:
    print(i)

"""E nós também podemos checar o conteúdo de uma lista usando a expressão "in"
"""

3 in lista

6 in lista

"""A função embutida len() devolve o tamanho de uma lista:"""

len(lista)

"""---

**Exercício 8**

Faça um programa que leia um número indeterminado de valores, correspondentes a notas, encerrando a entrada de dados quando for informado um valor igual a -1 (que não deve ser armazenado).

Após esta entrada de dados, faça:
1. Mostre a quantidade de valores que foram lidos;
1. Exiba todos os valores na ordem em que foram informados;
1. Exiba todos os valores na ordem inversa à que foram informados;
1. Calcule e mostre a soma dos valores;
1. Calcule e mostre a média dos valores;
1. Calcule e mostre a quantidade de valores acima da média calculada;
1. Calcule e mostre a quantidade de valores abaixo de sete;
1. Encerre o programa com uma mensagem;
"""



#@title Resposta
notas = []

while True:
    nota = float(input("Digite uma nota: "))
    notas.append(nota)
    if nota == -1: break

print("Foram lidos %i valores." % len(notas))

print("\nValores informados: ")
for nota in notas:
    print(nota)

print("\nValores informados (ordem inversa): ")
notas.reverse()
for nota in notas:
    print(nota)

soma = 0
for nota in notas:
    soma += nota
print("\nA soma de valores é", soma)

soma /= len(notas)
print("\nA média dos valores é", soma)

acima = 0
for nota in notas:
    if nota > soma:
        acima += 1
print("\nNúmero de notas acima da média é", acima)

abaixo = 0
for nota in notas:
    if nota < 7:
        abaixo += 1
print("\nNúmero de notas abaixo de 7 é", abaixo)

"""---

#### Tuplas

Uma tupla consiste em uma sequência de valores separados por vírgulas, por exemplo:
"""

tupla = (1, 2, 3)
tupla

tupla = 1, 2, 3
tupla

"""Como você pode ver no trecho acima, na saída do console as tuplas são sempre envolvidas por parênteses, assim tuplas aninhadas podem ser lidas corretamente. Na criação, tuplas podem ser envolvidas ou não por parênteses, desde que o contexto não exija os parênteses (como no caso da tupla dentro de uma expressão maior). Não é possível atribuir itens individuais de uma tupla, contudo é possível criar tuplas que contenham objetos mutáveis, como listas.

"""

tupla = 1, 2, [3, 4, 5]
tupla

"""Tuplas são muito similares a listas, entretanto são objetos imutaveis que ocupam menos memória e são mais eficientes computacionalmente"""

print(tupla[0])
print(tupla[::-1])
print(1 in tupla)

"""
Apesar de tuplas serem similares a listas, elas são frequentemente utilizadas em situações diferentes e com propósitos distintos. Tuplas são imutáveis, e usualmente contém uma sequência heterogênea de elementos que são acessados via desempacotamento (ver a seguir nessa seção) ou índice (ou mesmo por um atributo no caso de namedtuples). Listas são mutáveis, e seus elementos geralmente são homogêneos e são acessados iterando sobre a lista."""

tupla[0] = 7

lista = list(tupla)
lista

tupla = tuple(lista)
tupla

"""Um problema especial é a criação de tuplas contendo 0 ou 1 itens: a sintaxe usa certos truques para acomodar estes casos. Tuplas vazias são construídas por um par de parênteses vazios; uma tupla unitária é construída por um único valor e uma vírgula entre parênteses (não basta colocar um único valor entre parênteses). Feio, mas funciona. Por exemplo:"""

tupla = (1, )
tupla

tupla = ()
type(tupla)

"""---

#### Dicionários

Outra estrutura de dados muito útil embutida em Python é o dicionário, cujo tipo é dict. Dicionários são também chamados de “memória associativa” ou “vetor associativo” em outras linguagens. Diferente de sequências que são indexadas por inteiros, dicionários são indexados por chaves (keys), que podem ser de qualquer tipo imutável (como strings e inteiros). Tuplas também podem ser chaves se contiverem apenas strings, inteiros ou outras tuplas. Se a tupla contiver, direta ou indiretamente, qualquer valor mutável, não poderá ser chave. Listas não podem ser usadas como chaves porque podem ser modificadas internamente pela atribuição em índices ou fatias, e por métodos como append() e extend().

Um bom modelo mental é imaginar um dicionário como um conjunto não-ordenado de pares chave:valor, onde as chaves são únicas em uma dada instância do dicionário. Dicionários são delimitados por chaves: {}, e contém uma lista de pares chave:valor separada por vírgulas. Dessa forma também será exibido o conteúdo de um dicionário no console do Python. O dicionário vazio é {}.
"""

dicionario = {"nome": "Pedro", "sobrenome": "Forli", "idade": 20}
dicionario

dicionario["nome"]

"""As principais operações em um dicionário são armazenar e recuperar valores a partir de chaves. Também é possível remover um par chave:valor com o comando del. Se você armazenar um valor utilizando uma chave já presente, o antigo valor será substituído pelo novo. Se tentar recuperar um valor usando uma chave inexistente, será gerado um erro."""

print(dicionario)
del dicionario["idade"]
print(dicionario)

dicionario["nome"] = "Mateus"
dicionario

dicionario["nome"]

dicionario["idade"]

"""Executar list(d) em um dicionário devolve a lista de todas as chaves presentes no dicionário, na ordem de inserção (se desejar ordená-las basta usar a função sorted(d)). Para verificar a existência de uma chave, use o operador in."""

"Mateus" in dicionario

"nome" in dicionario

list(dicionario)

tuple(dicionario)

"""Dicionários, assim como listas, possuem métodos pré-definidos que ajudam a trabalhar com a estrutura

KEYS: Lista de chaves do dicionário
"""

for k in dicionario.keys():
    print(k)

"nome" in dicionario.keys()

for k in dicionario:
    print(k)

"""VALUES: Lista de valores do dicionário"""

dicionario.values()

list(dicionario.values())

"Mateus" in dicionario.values()

"""ITEMS: Pares de chave e valor"""

dicionario.items()

for k, v in dicionario.items():
    print(k, "->", v)

"""GET: Obtém o valor do dicionário"""

dicionario["nome"]

dicionario.get("nome")

dicionario["idade"]

dicionario.get("idade")

"""---

**Exercício 9**

Escreva um programa que receba quantas entradas o usuário desejar e depois
crie um novo contato para cada entrada (Nome, Telefone, Endereço, Email), e
por fim imprima, em ordem alfabética, a agenda de contatos
"""



#@title Resposta
nomes = []
agenda = {}

while True:
    ordem = input('Deseja adicionar um novo contato(add) ou parar a execução(stop)').lower()

    if not ordem.isalpha():
        print("Digite apenas letras!")

    elif ordem.startswith('a'):
        contato = {}


        nome = input('Digite o nome do contato: ')
        if not nome[0].isupper():
            nome = nome[0].upper() + nome[1:]

        nomes.append(nome)

        tel = input('Digite o telefone do contato: ')
        contato['Telefone'] = tel

        end = input('Digite o endereço do contato: ')
        contato['Endereço'] = end

        email = input('Digite o Email do contato: ')
        contato['Email'] = email

        agenda[nome] = contato

    elif ordem.startswith('s'):
        break

print('A G E N D A\n')
nomes.sort()
for nome in nomes:
    print('Nome: ', nome)
    print('Telefone: ', agenda[nome]['Telefone'])
    print('Endereço: ', agenda[nome]['Endereço'])
    print('Email: ', agenda[nome]['Email'])
    print()

"""---

#### Sets

Python também inclui um tipo de dados para conjuntos, chamado set. Um conjunto é uma coleção desordenada de elementos, sem elementos repetidos. Usos comuns para conjuntos incluem a verificação eficiente da existência de objetos e a eliminação de itens duplicados. Conjuntos também suportam operações matemáticas como união, interseção, diferença e diferença simétrica.

Chaves ou a função set() podem ser usados para criar conjuntos. Note: para criar um conjunto vazio você precisa usar set(), não {}; este último cria um dicionário vazio.
"""

conj = {1, 2, 3}
conj

conj = set([1, 2, 3])
conj

{1, 2, 3, 3, 3, 4, 5}

conj[0]

"""Sets permitem calculos de conjuntos como intersecção, sub e superset"""

conj1 = {1, 2, 3}
conj2 = {3, 4, 5}
conj3 = {1, 2, 3, 4, 5}

print(conj1 - conj2)
print(conj1.intersection(conj2))
print(conj3.issuperset(conj2))
print(conj1.issubset(conj3))

list(set([1, 2, 3, 4, 5, 5, 6, 7, 8, 8]))

"""---

### Variáveis de Texto

Além de números, Python também pode manipular strings (sequências de caracteres), que podem ser expressas de diversas formas. Elas podem ser delimitadas por aspas simples ('...') ou duplas ("...") e teremos o mesmo resultado. \ pode ser usada para escapar aspas:
"""

"Olá mundo"

a = "Olá mundo"

a

"Ele disse \"eu gosto de sorvete\""

"""Na interpretação interativa, a string de saída é delimitada com aspas e caracteres especiais são escapados com barras invertidas. Embora isso possa às vezes parecer diferente da entrada (as aspas podem mudar), as duas strings são equivalentes. A string é delimitada com aspas duplas se a string contiver uma única aspa simples e nenhuma aspa dupla, caso contrário, ela é delimitada com aspas simples.

Se não quiseres que os caracteres sejam precedidos por \ para serem interpretados como caracteres especiais, poderás usar strings raw (N.d.T: “crua” ou sem processamento de caracteres de escape) adicionando um r antes da primeira aspa:
"""

print("C:\neusa")

print("C:\\neusa")

print(r"C:\neusa")

"""As strings literais podem abranger várias linhas. Uma maneira é usar as aspas triplas: '''...''' ou '''...'''. O fim das linhas é incluído automaticamente na string, mas é possível evitar isso adicionando uma \ no final. O seguinte exemplo:

\
Uma string com múltiplas
linhas a ser mostrada\

Strings podem ser concatenadas (coladas) com o operador +, e repetidas com *:
"""

3 * 'un' + 'ium'

"""Duas ou mais strings literais (ou seja, entre aspas) ao lado da outra são automaticamente concatenados."""

'Py' 'thon'

"""Esse recurso é particularmente útil quando você quer quebrar strings longas:"""

texto = (
    "Olha, esse é um texto enorme que eu vou querer deixar "
    "entre múltiplas linhas para o meu código ser mais legível"
)
texto

"""Isso só funciona com duas strings literais, não com variáveis ou expressões:"""

p1 = "Py"
#p1 "thon"

"""Se você quiser concatenar variáveis ou uma variável e uma literal, use +:"""

p1 + "thon"

"""As strings podem ser indexadas (subscritas), da mesma maneira que listas e tuplas"""

["P", "y", "t", "h", "o", "n"]
p = "Python"
print(p[0])
print(p[5])

p[-1]

p[1:3]

p[2:] + p[3:4]

p[42]

p[42:]

p[2:42]

"""As strings do Python não podem ser alteradas — uma string é imutável. Portanto, atribuir a uma posição indexada na sequência resulta em um erro:"""

p[0] = "J"

"""Se você precisar de uma string diferente, deverá criar uma nova:"""

"J" + p[1:]

"""A função embutida len() devolve o comprimento de uma string:"""

len(p)

"""Assim como todas as variáveis numéricas strings também possuem uma função que permite converter uma expressão em texto."""

str([1, 2, 3])

"""Como já vimos, strings podem ser criadas a partir de outras variáveis apresentando formatações específicas. Há 4 principais tipos de sintaxe para isso:

1) Operador %: A formatação que vimos no print com o uso do % para colocar inteiros e reais

<img src="https://i.stack.imgur.com/j1NqG.png" />
"""

print("Olá %s %d" % ("mundo", 1))

"""2) str.format: Utiliza a sintaxe do .format passando para a string o nome de variáveis específicas"""

nome = "Pedro"
errno = "badc0ffee"
print("Olá {}, há um erro 0x{}!".format(nome, errno))
print("Olá {nome}, há um erro 0x{errno}!".format(errno=errno, nome=nome))

"""3) f-strings: O formato que mais utilizaremos no curso, na qual ao colocar um "f" na frente da string podemos passar as variáveis diretamente para ela"""

print(f"Olá, {nome}")
print(f"Olá, {1 + 2 * 3}")
print(f"Olá {nome}, há um erro 0x{errno}!")

"""4) Templates: Gera strings que esperam determinadas variáveis para serem utilizadas com template múltiplas vezes"""

from string import Template

s1 = Template("Olá, $nome")
s2 = Template("Olá $nome, há um erro 0x$errno!")

print(s1.substitute(nome=nome))
print(s2.substitute(nome=nome, errno=errno))

"""Por fim, é importante destacar que há uma série de ferramentas pré-prontas para se trabalhar na manipulação de strings em python, os chamados métodos. Destacamos abaixo o mais utilizados

UPPER / LOWER: Converte um string para maiscula / minuscula
"""

s = "Olá Mundo"
print(s.lower())
print(s.upper())

"""ISDIGIT: Checa se a string é numérica"""

s = "123"
print(s.isdigit())

"""SPLIT: Divide a string de acordo com um separador"""

s = "Olá Mundo"
s.split(" ")

"""JOIN: Junta uma lista ou tupla de textos em um string usando uma string de junção"""

l = ['Olá', 'Mundo']
print(" ".join(l))
print(", ".join(l))
print(" --> ".join(l))

"""STRIP: Elimina caracteres vazios nos extremos da string"""

s = " Olá Mundo   "
s

s.strip()

"""---

**Exercício 10**

Vamos criar um programa que reproduza a Cifra de Cesar.

Este era um método utilizado pelos Romanos de criptografia de mensagens, na qual se codificava o valor de cada letra do alfabeto a um número e então, por meio de uma chave numérica, se deslocava as letras de acordo com o valor dessa chave.

Por exemplo se codificassemos a = 1, b = 2, c = 3, ... a letra "a" codificada com chave 3, se tornaria "d", porque a=1 e d=4 (4 = 1 + 3).

Escreva um programa que permita criptografar e descriptografar uma mensagem.

Primeiro peça para o usuário informar se ele deseja criptografar ou descriptografar uma mensagem. Depois peça o valor da chave, obrigando-o a informar um valor entre 1 e 26. Em seguida, peça uma mensagem a ser traduzida e converta-a para minúsculo, também remova caracteres com acento ou "ç" da string. Por fim aplique o método da cifra para traduzir a mensagem.

DICA: Pode ser útil olhar para as funções ord e chr.
"""



#@title Resposta
TAM_MAX_CH = 26

# primeiro nós pegamos o modo a ser aplicado na string
while True:
    modo = input("Você deseja criptografar ou decriptografar? ").lower()
    if modo in ["criptografar", "c", "decriptografar",  "d"]:
        break
    else:
        print("Entre 'criptografar' ou 'c' ou 'decriptografar' ou 'd'.")

# depois pedimos a mensagem a ser processada
mensagem = input("Entre sua mensagem: ").lower()

# garante que a mensagem não tenha caractéres com acento ou ç
orig = "áàãâéèêíìîóòõôúùûç"
sub = "aaaaeeeiiioooouuuc"
repl = dict(zip(orig, sub))
for o, r in repl.items():
    mensagem = mensagem.replace(o, r)

# pedimos então a chave da criptografia
chave = 0
while True:
    chave = int(input(f"Entre o número da chave (1-{TAM_MAX_CH}): "))
    if 1 <= chave <= TAM_MAX_CH:
        break
    else:
        print(f"A chave deve estar entre 1 e {TAM_MAX_CH}")

# Nós então traduzimos a mensagem
if modo[0] == "d":
    chave *= -1

traduzido = ""

# para cada caracter na mensagem
for simbolo in mensagem:
    # nós verificamos se o caracter é alpha numérico
    if simbolo.isalpha():
        # se for nós pegamos a ordem do simbolo
        num = ord(simbolo)

        # então nós adicionamos o valor da chave a ordem
        num += chave

        # nós então garantimos que o simbolo não ultrapasse os
        # valores de ordem entre A e Z
        if num > ord("z"):
            num -= 26
        elif num < ord("a"):
            num += 26

        # convertemos o simbolo para um caracter e adicionamos
        # a mensagem
        traduzido += chr(num)
    else:
        traduzido += simbolo

# imprime a mensagem traduzida
print(traduzido)

"""---

## Módulos

Uma das maiores vantagens do python é sua modularidade e comunidade. Porque Python é uma linguagem aberta, há muitas pessoas que desenvolvem para a mesma, e muitas vezes sua vida fica muito mais fácil utilizando esse código pré escrito do que o reescrevendo.

Essas bibliotecas são chamadas de módulo e podem ser importandas utilizando a sintexe do import
"""

import math

"""Ao fazer isso podemos acessar as múltiplas funcionalidades daquele módulo utilizando a sintaxe do ponto"""

math.sqrt(4)

math.e

"""Além disso, podemos importar funções específicas de cada módulo utilizando a sintaxe do from"""

from math import sqrt
sqrt(4)

from math import sqrt, ceil
ceil(2.1)

"""Caso já tenhamos váriaveis ou funções com os nomes desses módulos podemos renomear-los usando a expressão "as"
"""

from math import sqrt as raiz
raiz(4)

import math as matematica
matematica.ceil(2.1)

"""---

**Exercício 11**

Escreva um programa para simular o jogo das portas. Faça um programa que tenha
a saída como a seguinte:

> <p>Olá, bem-vindo ao nosso programa! Vamos ver se você vai ganhar um carro ou não!</p>
> <p>Escolha uma porta: 3</p>
> <p>Você escolheu a porta 3, mas</p>
> <p>eu lhe informo que na porta 2 há um bode.</p>
> <p>Deseja trocar de porta (1 - Sim/ 0 - Não): 1</p>
> <p>Ganhou um carro!</p>

Sortei de forma aleatória a porta com o carro. Utilize o módulo random (https://docs.python.org/3/library/random.html) para isso.
"""



#@title Resposta
import random

print("Olá, bem-vindo ao nosso programa! Vamos ver se você vai ganhar um carro ou não!")

porta = int(input("Escolha uma porta: "))
# premio = random.choice([1, 2, 3])
# premio = random.randrange(1, 4)
premio = random.randint(1, 3)

if premio != 1 and porta != 1:
    bode = 1
elif premio != 2 and porta != 2:
    bode = 2
else:
    bode = 3

print("Você escolheu a porta %i, mas" % porta)
print("eu lhe informo que na porta %i há um bode." % bode)

decisão = int(input("Deseja trocar de porta (1 - Sim/ 0 - Não): "))

if decisão == 1:
    if porta != 1 and bode != 1:
        porta = 1
    elif porta != 2 and bode != 2:
        porta = 2
    else:
        porta = 3

if porta == premio:
    print("Ganhou um carro!")
else:
    print("Não ganhou um carro...")

"""---

## Funções

### Definição

A palavra reservada def inicia a definição de uma função. Ela deve ser seguida do nome da função e da lista de parâmetros formais entre parênteses. Os comandos que formam o corpo da função começam na linha seguinte e devem ser indentados.

<img src="https://bham-carpentries.github.io/2018-12-17-bham_python-novice-inflammation/fig/python-function.svg" />
"""

def ola_mundo(nome):
    texto_de_ola = f"Olá {nome}! Prazer em te conhecer"
    print(texto_de_ola)

ola_mundo("Pedro")

ola_mundo("Mateus")

"""### Variáveis de Função

A execução de uma função cria uma nova tabela de símbolos para as variáveis locais da função. Mais precisamente, todas as atribuições de variáveis numa função são armazenadas na tabela de símbolos local; referências a variáveis são buscadas primeiro na tabela de símbolos local, em seguida na tabela de símbolos locais de funções delimitadoras ou circundantes, depois na tabela de símbolos global e, finalmente, na tabela de nomes da própria linguagem.
"""

ola_mundo("Pedro")

texto_de_ola

texto_de_ola = "Olá Fulano! Prazer em te conhecer"
ola_mundo("Pedro")

texto_de_ola

def ola_mundo(nome):
    global texto_de_ola
    print(texto_de_ola)

    texto_de_ola = f"Olá {nome}! Prazer em te conhecer"
    print(texto_de_ola)

ola_mundo("Pedro")

texto_de_ola

"""### Argumentos

É possível definir funções com um número variável de argumentos. Existem três formas, que podem ser combinadas.

**Argumentos com valor padrão**: A mais útil das três é especificar um valor padrão para um ou mais argumentos. Isso cria uma função que pode ser invocada com menos argumentos do que os que foram definidos. Por exemplo:
"""

def ola_mundo(nome, sobn="Forli"):
    texto_de_ola = f"Olá {nome} {sobn}! Prazer em te conhecer"
    print(texto_de_ola)

ola_mundo("Pedro")
ola_mundo("Mateus")
ola_mundo("Cristiano", "Ronaldo")
ola_mundo("Mathias", sobn="Viña")

"""Aviso importante: Valores padrões são avaliados apenas uma vez. Isso faz diferença quando o valor é um objeto mutável, como uma lista, dicionário, ou instâncias de classes. Por exemplo, a função a seguir acumula os argumentos passados, nas chamadas subsequentes:"""

lista = [1, 2, 3, 4]
def altera_lista(lista):
    lista.append(5)
print(lista)
altera_lista(lista)
print(lista)

"""**Argumentos nomeados**: Funções também podem ser chamadas usando argumentos nomeados da forma chave=valor. Por exemplo, a função a seguir:"""

def papai_noel(vel, acao="voou", presente="chocalho", cor="azul"):
    print(
        f"Papai noel {acao}"
        f" a {vel} km/h"
        f" para me dar um {presente}"
        f" de cor {cor}"
    )

papai_noel(1000)
papai_noel(1000, "correu", "uno")
papai_noel(vel=1000)
papai_noel(vel=1000, acao="correu")
papai_noel(acao="correu", vel=1000)
papai_noel(1000, cor="vermelha")

papai_noel()

papai_noel(vel=5, "correu")

papai_noel("correu", vel=5)

papai_noel(vel=5, comida="biscoito")

"""Em uma chamada de função, argumentos nomeados devem vir depois dos argumentos posicionais. Todos os argumentos nomeados passados devem corresponder com argumentos aceitos pela função (ex. comida não é um argumento nomeado válido para a função papai_noel), mas sua ordem é irrelevante. Isto também inclui argumentos obrigatórios (ex.: papai_noel(vel=1000) funciona). Nenhum argumento pode receber mais de um valor. Eis um exemplo que não funciona devido a esta restrição:"""

def function(a):
    pass

function(0, a=0)

"""Quando um último parâmetro formal no formato \*\*nome está presente, ele recebe um dicionário (veja Tipo mapeamento — dict) contendo todos os argumentos nomeados, exceto aqueles que correspondem a um parâmetro formal. Isto pode ser combinado com um parâmetro formal no formato \*nome (descrito na próxima subseção) que recebe uma tupla contendo os argumentos posicionais, além da lista de parâmetros formais. (\*nome deve ocorrer antes de \*\*nome.) Por exemplo, se definirmos uma função assim:"""

def loja_de_queijo(tipo, *args, **kwargs):
    print("Você tem do tipo", tipo, "?")
    print("Foi mal, mas acabou todo queijo", tipo)

    for arg in args:
        print(arg)
    print("-" * 40)

    for kw in kwargs:
        print(kw, ":", kwargs[kw])

loja_de_queijo(
    "Prato",
    "É bem procurado este queijo.",
    "A galera come pra caramba, mas você pode ver com:",
    loja="Alegria do Queijo",
    dono="Fernando Cabra",
    rua="Cheddar com Faria Lima"
)

loja_de_queijo("Prato", *lista, **dicionario)

"""**Parâmetros especiais**: Por padrão, argumentos podem ser passadas para uma função Python tanto por posição quanto explicitamente pelo nome. Para uma melhor legibilidade e desempenho, faz sentido restringir a maneira pelo qual argumentos possam ser passados, assim um desenvolvedor precisa apenas olhar para a definição da função para determinar se os itens são passados por posição, por posição e nome, ou por nome.

A definição de uma função pode parecer com:

def f(pos1, pos2, /, pos_or_kwd, *, kwd1, kwd2):
      -----------    ----------     ----------
        |             |                  |
        |        Positional or keyword   |
        |                                - Keyword only
         -- Positional only

*Argumentos posicional-ou-nomeados*: Se / e * não estão presentes na definição da função, argumentos podem ser passados para uma função por posição ou por nome.

*Parâmetros somente-posicionais*: Olhando com um pouco mais de detalhes, é possível definir certos parâmetros como somente-posicional. Se somente-posicional, a ordem do parâmetro importa, e os parâmetros não podem ser passados por nome. Parâmetros somente-posicional são colocados antes de / (barra). A / é usada para logicamente separar os argumentos somente-posicional dos demais parâmetros. Se não existe uma / na definição da função, não existe parâmetros somente-posicionais.

Parâmetros após a / podem ser posicional-ou-nomeado ou somente-nomeado.

*Argumentos somente-nomeados*: Para definir parâmetros como somente-nomeado, indicando que o parâmetro deve ser passado por argumento nomeado, colocamos um * na lista de argumentos imediatamente antes do primeiro parâmetro somente-nomeado.
"""

def funcao_normal(arg):
    print(arg)

def somente_posicional(arg, /):
    print(arg)

def somente_chaveado(*, arg):
    print(arg)

def combinado(pos, /, normal, *, chave):
    print(pos, normal, chave)

funcao_normal(1)
funcao_normal(arg=1)

somente_posicional(1)
somente_posicional(arg=1)

somente_chaveado(arg=1)
somente_chaveado(1)

combinado(1, normal=3, chave="chave")

"""### Retorno

É fácil escrever uma função que retorna o texto ao invés de exibi-los:
"""

def ola_mundo(nome):
    return f"Olá {nome}! Prazer em te conhecer"

texto = ola_mundo("Pedro")
texto

1 == None

"""A instrução return finaliza a execução e retorna um valor da função. return sem qualquer expressão como argumento retorna None. Atingir o final da função também retorna None.

A instrução também pode retornar múltiplos valores ao invés de apenas um, gerando uma tupla como resultado
"""

def operacoes(a, b):
    return a + b, a - b, a * b

print(operacoes(5, 10))
v = operacoes(5, 10)
print(v)
v1, v2, v3 = operacoes(5, 10)
print(v1, v2, v3)

"""### Docstring

Opcionalmente, a primeira linha do corpo da função pode ser uma literal string, cujo propósito é documentar a função. Se presente, essa string chama-se docstring. (Há mais informação sobre docstrings na seção Strings de documentação.) Existem ferramentas que utilizam docstrings para produzir automaticamente documentação online ou para imprimir, ou ainda, permitir que o usuário navegue interativamente pelo código. É uma boa prática incluir sempre docstrings em suas funções, portanto, tente fazer disso um hábito.
"""

def ola_mundo(nome):
    """
    Imprime uma mensagem de olá com o nome da pessoa

    :param nome: nome da pessoa a ser impresso
    """
    texto_de_ola = f"Olá {nome}! Prazer em te conhecer"
    print(texto_de_ola)

ola_mundo()

ola_mundo.__doc__

"""Em particular o padrão de documentação que utilizaremos é o Sphinx (https://www.sphinx-doc.org/en/master/).

Sphinx usa a sintaxe de palavra-chave (palavra reservada), que a maioria das linguagens de programação fazem. As palavras-chave mais importantes são:

- *param* e *type*: O valor do parâmetro e o tipo de variável.
- *return* e *rtype*: o valor de retorno e seu tipo.
- *:raise* : Descreve todos os erros que são levantados pelo código.
- *.. seealso::*: Leituras adicionais.
- *.. notes::*: Adicionar uma nota.
- *.. warning::*: Adicionar um aviso.
"""

def multiplica(a, b, c=1):
    """
    Retorna a multiplicação de todos os argumentos da função

    :param a: argumento 1
    :type a: int
    :param b: argumento 2
    :type b: int
    :param c: argumento 3, padrão 0
    :type c: int, opcional
    :raises ValueError: se a == b

    :rtype: int
    :return: multiplicação de todos os argumentos
    """
    if a == b:
        raise ValueError("arg1 deve ser diferente de arg2")
    return a * b * c

"""Para mais detalhes veja https://sphinx-rtd-tutorial.readthedocs.io/en/latest/docstrings.html

### Type hint

Em Python utiliza-se tipagem dinâmica, na qual os tipos de variáveis são atribuidos no momento da execução do código. Por exemplo, quando definimos a função ola_mundo, a príncipio não informamos qual era o tipo da variavel "nome", mas de alguma maneira, em algum momento, a linguagem conseguiu inferir que nome deveria ser do tipo "string" e com isso executar os blocos de código de acordo.

Podemos, por outro lado, colocar de forma explícita o tipo de uma determinada variável utilizando o "type hint". Como o nome implica (type hint = dica de tipo) esta especificação não forçará a linguagem a utilizar um determinado tipo para uma variável, mas ajudará na documentação e em verificações do código, e serão muito utilizados no nosso código
"""

ola_mundo("Pedro")

ola_mundo(2 + 3j)

def ola_mundo(nome: str) -> None:
    """
    Imprime uma mensagem de olá com o nome da pessoa

    :param nome: nome da pessoa a ser impresso
    :type nome: str
    """
    texto_de_ola = f"Olá {nome}! Prazer em te conhecer"
    print(texto_de_ola)

import typing

ola_mundo(2 + 3j)

"""Para mais detalhes https://diogommartins.medium.com/python-3-e-type-hints-40e80a9e8214

### Funções anônimas

Pequenas funções anônimas podem ser criadas com a palavra-chave lambda. Esta função retorna a soma de seus dois argumentos: lambda a, b: a+b. As funções lambda podem ser usadas sempre que objetos função forem necessários. Eles são sintaticamente restritos a uma única expressão. Semanticamente, eles são apenas açúcar sintático para uma definição de função normal. Como definições de funções aninhadas, as funções lambda podem referenciar variáveis contidas no escopo:
"""

def cria_incrementador(n):
    return n + 1
cria_incrementador(10)

cria_incrementador = lambda n: n + 1
cria_incrementador(10)

def cria_incrementador(n):
    return lambda x: x + n

f1 = cria_incrementador(1)
f2 = cria_incrementador(42)

print(f1(0))
print(f2(0))

"""O exemplo acima usa uma expressão lambda para retornar uma função. Outro uso é passar uma pequena função como um argumento:"""

pares = [(2, "dois"), (4, "quatro"), (1, "um"),  (3, "três")]
pares.sort(key=lambda par: par[1])
pares

"""---

**Exercício 12**

No jogo dos 15 o objetivo é receber uma matriz com números de 1 a 15 ordenados de forma aleatória e ir trocando as peças até que se consiga obter um tabuleiro com os números ordenados.

<img src="https://images-na.ssl-images-amazon.com/images/I/8107cskBQ3L.png" width=200 height=150 />

Neste exercício iremos reproduzir o jogo dos 15 através da construção de funções específicas. Você já começa com algumas funções pré-definidas, como gera_matriz, mas precisará completar as demais:

1. troca_elemento: Troca os elementos de uma matriz de itens
1. verifica_se_venceu: Recebe uma matriz 4x4 e verifica se os números estão ordenados de forma que o jogador venceu
1. verifica_jogada: Verifica se a jogada escolhida pelo usuário é válida

Você pode fazer quantas funções adcionais quanto quiser

Organize o seu jogo dentro da função main. Dê para o usuário a toda rodada a opção de desistir(0) ou de inserir uma posição(1), a posição inserida será feita colocando a linha e coluna da matriz, por exemplo 11 significa que
estamos nos referenciando ao elemento da linha 1 coluna 1, 32 se referencia ao elemento da linha 3 coluna 2
"""

import random
import typing
import time
from IPython.display import clear_output


def gera_matriz() -> typing.List[typing.List[int]]:
    """
    Gera uma matriz 4x4 com elementos em posições aleatórias
    entre 0 e 15

    :return: matriz 4x4 com valores entre 0 e 15
    """
    matriz = list()
    lista = list(range(16))
    for j in range(4):
        linha = []
        for i in range(4):
            x = random.choice(lista)
            linha.append(x)
            lista.remove(x)
        matriz.append(linha)
    return matriz


def acha_pos_zero(matriz: typing.List[typing.List[int]]) -> int:
    """
    Função que procura e devolve a posição do zero da matriz (espaço vazio)

    :param matriz: matriz com os elementos do jogo
    :return: posição do elemento 0
    """
    for i in range(len(matriz)):
        for j in range(len(matriz[0])):
            if matriz[i][j] == 0:
                return (i + 1) * 10 + j + 1


def imprime_jogo(
    matriz: typing.List[typing.List[int]]
) -> None:
    """
    Imprime o estado atual do tabuleiro

    :param matriz: matriz com os elementos do jogo
    """
    for i in range(4):
        print("+------+------+------+------+")
        for j in range(4):
            print("+  %02d " % matriz[i][j], end=" ")
        print("+")
    print("+------+------+------+------+")


def troca_elemento(
    pos1: int,
    pos2: int,
    matriz: typing.List[typing.List[int]]
) -> None:
    """
    Dada uma matriz (listas de listas) de tamanho 4x4 troque os
    elementos contidos na posição 1 com o elemento da posição 2,
    na qual os elementos são representados por um número inteiro
    cujo valor correponde a linha e coluna do elemento.

    Por exemplo pos1 = 11 -> elemento da primeira linha e primeira coluna

    Assim, se pos1 = 11, pos2 = 12 e
    matriz =
        1  2  3  4
        5  6  7  8
        9 10 11 12

    Queremos obter
        2  1  3  4
        5  6  7  8
        9 10 11 12

    As mudanças da matriz devem ser feitas dentro da função, sem necessidade
    de retornar uma nova matriz

    :param pos1: número inteiro da posição 1
    :param pos2: número inteiro da posição 2
    :param matriz: matriz de elementos
    """
    pass


def verifica_jogada(pos: int, zero_pos: int) -> bool:
    """
    Verifca se a jogada selecionada é valida

    :param pos: posição do elemento a ser trocado
    :param zero_pos: posição do elemento 0
    :return: True se a jogada é válida
    """
    pass


def verifica_se_venceu(matriz: typing.List[typing.List[int]]) -> bool:
    """
    Verifica se o jogador venceu o jogo

    :param matriz: matriz com os elementos do jogo
    :return: True se o jogador venceu
    """
    pass


def main() -> None:
    """
    Função principal do jogo
    """
    # inicializa o jogo
    jogo = gera_matriz()
    zero_pos = acha_pos_zero(jogo)
    jogando = True
    venceu = False

    # cria o loop principal do jogo
    while jogando:
        # imprime o estado do jogo
        clear_output(wait=True)
        time.sleep(0.3)
        imprime_jogo(jogo)
        time.sleep(0.3)

        # pede a posição até obter uma posição válida
        pos = int(input("Digite a posição do elemento que você deseja trocar: "))
        while not verifica_jogada(pos, zero_pos):
            print("Entrada inválida. Digite novamente")
            pos = int(input("Digite a posição do elemento que você deseja trocar: "))

        # executa a troca de elementos
        troca_elemento(pos, zero_pos, jogo)
        zero_pos = pos

        # verifica se o usuário venceu o jogo
        venceu = verifica_se_venceu(jogo)
        jogando = not venceu

    # imprime o resultado do jogo
    if venceu:
        print("Parabens, você venceu!!!")
    else:
        print("Obrigado por jogar.")

main()

#@title Resposta
import random
import typing
import time
from IPython.display import clear_output


def gera_matriz() -> typing.List[typing.List[int]]:
    """
    Gera uma matriz 4x4 com elementos em posições aleatórias
    entre 0 e 15

    :return: matriz 4x4 com valores entre 0 e 15
    """
    matriz = list()
    lista = list(range(16))
    for j in range(4):
        linha = []
        for i in range(4):
            x = random.choice(lista)
            linha.append(x)
            lista.remove(x)
        matriz.append(linha)
    return matriz


def acha_pos_zero(matriz: typing.List[typing.List[int]]) -> int:
    """
    Função que procura e devolve a posição do zero da matriz (espaço vazio)

    :param matriz: matriz com os elementos do jogo
    :return: posição do elemento 0
    """
    for i in range(len(matriz)):
        for j in range(len(matriz[0])):
            if matriz[i][j] == 0:
                return (i + 1) * 10 + j + 1


def imprime_jogo(
    matriz: typing.List[typing.List[int]]
) -> None:
    """
    Imprime o estado atual do tabuleiro

    :param matriz: matriz com os elementos do jogo
    """
    for i in range(4):
        print("+------+------+------+------+")
        for j in range(4):
            print("+  %02d " % matriz[i][j], end=" ")
        print("+")
    print("+------+------+------+------+")


def troca_elemento(
    pos1: int,
    pos2: int,
    matriz: typing.List[typing.List[int]]
) -> None:
    """
    Dada uma matriz (listas de listas) de tamanho 4x4 troque os
    elementos contidos na posição 1 com o elemento da posição 2,
    na qual os elementos são representados por um número inteiro
    cujo valor correponde a linha e coluna do elemento.

    Por exemplo pos1 = 11 -> elemento da primeira linha e primeira coluna

    Assim, se pos1 = 11, pos2 = 12 e
    matriz =
        1  2  3  4
        5  6  7  8
        9 10 11 12

    Queremos obter
        2  1  3  4
        5  6  7  8
        9 10 11 12

    As mudanças da matriz devem ser feitas dentro da função, sem necessidade
    de retornar uma nova matriz

    :param pos1: número inteiro da posição 1
    :param pos2: número inteiro da posição 2
    :param matriz: matriz de elementos
    """
    elemento1 = matriz[pos1 // 10 - 1][pos1 % 10 -1]
    elemento2 = matriz[pos2 // 10 - 1][pos2 % 10-1]
    matriz[pos1 // 10-1][pos1 % 10 - 1] = elemento2
    matriz[pos2 // 10-1][pos2 % 10 - 1] = elemento1


def verifica_jogada(pos: int, zero_pos: int) -> bool:
    """
    Verifca se a jogada selecionada é valida

    :param pos: posição do elemento a ser trocado
    :param zero_pos: posição do elemento 0
    :return: True se a jogada é válida
    """
    linha = pos // 10
    coluna = pos % 10

    linha_zero = zero_pos // 10
    coluna_zero = zero_pos % 10

    if linha < 1 or linha > 4 or coluna < 1 or coluna > 4:
        return False
    else:
        return (
            (linha == linha_zero -1 and coluna == coluna_zero)
            or (linha == linha_zero and (coluna == coluna_zero-1 or coluna == coluna_zero+1))
            or (linha == linha_zero+1 and coluna == coluna_zero)
        )


def verifica_se_venceu(matriz: typing.List[typing.List[int]]) -> bool:
    """
    Verifica se o jogador venceu o jogo

    :param matriz: matriz com os elementos do jogo
    :return: True se o jogador venceu
    """
    em_linha = list()
    for l in matriz:
        em_linha += l
    return em_linha == sorted(em_linha)


def main() -> None:
    """
    Função principal do jogo
    """
    # inicializa o jogo
    jogo = gera_matriz()
    zero_pos = acha_pos_zero(jogo)
    jogando = True
    venceu = False

    # cria o loop principal do jogo
    while jogando:
        # imprime o estado do jogo
        clear_output(wait=True)
        time.sleep(0.3)
        imprime_jogo(jogo)
        time.sleep(0.3)

        # pede a posição até obter uma posição válida
        pos = int(input("Digite a posição do elemento que você deseja trocar: "))
        while not verifica_jogada(pos, zero_pos):
            print("Entrada inválida. Digite novamente")
            pos = int(input("Digite a posição do elemento que você deseja trocar: "))

        # executa a troca de elementos
        troca_elemento(pos, zero_pos, jogo)
        zero_pos = pos

        # verifica se o usuário venceu o jogo
        venceu = verifica_se_venceu(jogo)
        jogando = not venceu

    # imprime o resultado do jogo
    if venceu:
        print("Parabens, você venceu!!!")
    else:
        print("Obrigado por jogar.")

main()

"""---

## Leitura de Dados

---

**NOTA**

Se você estiver executando este notebook a partir do google colab, seria necessário que você ajustasse o caminho para os diferentes arquivos. Entretanto, para faciliar a vida, iremos baixar os dados na pasta temporária do colab executando a célula abaixo.
"""

import urllib.request
urllib.request.urlretrieve("https://drive.google.com/uc?id=1SQ6GksfmYdgRn7Bku46XxBFG-aovSu0M&export=download", "usuarios.txt")
urllib.request.urlretrieve("https://drive.google.com/uc?id=1SQISXgA98wU_v1oRws57lvMhms2e2rDY&export=download", "palavras.txt")

"""Para ver o conteúdo da sua pasta execute o comando abaixo em uma nova célula"""

!dir "."

"""---

A função open() devolve um objeto arquivo, e é frequentemente usada com dois argumentos: open(nome_do_arquivo, modo).
"""

f = open("usuarios.txt", "r")
f.close()

f = open("usuarios - Copy.txt", "w")
f.close()

f = open("arquivo_teste.txt", "w")
f.close()

f = open("usuarios.txt", "a")
f.close()

f = open("usuarios.txt", "r+")
f.close()

"""O primeiro argumento é uma string contendo o nome/caminho do arquivo. O segundo argumento é outra string, contendo alguns caracteres que descrevem o modo como o arquivo será usado. modo pode ser 'r' quando o arquivo será apenas lido, 'w' para escrever (se o arquivo já existir seu conteúdo prévio será apagado), e 'a' para abrir o arquivo para adição; qualquer escrita será adicionada ao final do arquivo. A opção 'r+' abre o arquivo tanto para leitura como para escrita. O argumento modo é opcional, em caso de omissão será assumido 'r'.

Normalmente, arquivos são abertos em modo texto, ou seja, você lê e grava strings, de e para o arquivo, numa codificação específica. Se a codificação não for especificada, o padrão é dependente da plataforma/sistema operacional (consulte open()). Incluir 'b' ao modo abre o arquivo em modo binário: os dados são lidos e escritos na forma de bytes. Esse modo deve ser usado para todos os arquivos que não contenham texto.

Em modo texto, o padrão durante a leitura é converter terminadores de linha específicos da plataforma (\n no Unix, \r\n no Windows) para apenas \n. Ao escrever no modo de texto, o padrão é converter as ocorrências de \n de volta para os finais de linha específicos da plataforma. Essa modificação de bastidores nos dados do arquivo é adequada para arquivos de texto, mas corromperá dados binários, como arquivos JPEG ou EXE. Tenha muito cuidado para só usar o modo binário, ao ler e gravar esses arquivos.

É uma boa prática usar a palavra-chave with ao lidar com arquivos. A vantagem é que o arquivo é fechado corretamente após o término de sua utilização, mesmo que uma exceção seja levantada em algum momento. Usar with também é muito mais curto que escrever seu bloco equivalente try-finally:
"""

with open("usuarios.txt") as f:
    dados = f.read()
print(dados)
print(f.closed)

"""Se você não está usando a palavra reservada with, então você deveria chamar f.close() para fechar o arquivo e imediatamente liberar qualquer recurso do sistema usado por ele.

    Aviso Chamar f.write() sem usar a palavra reservada with ou chamar``f.close()`` pode resultar nos argumentos de f.write() não serem completamente escritos no disco, mesmo se o programa for encerrado com êxito.

Depois que um arquivo é fechado, seja por uma instrução with ou chamando f.close(), as tentativas de usar o arquivo falharão automaticamente.
"""

f = open("usuarios.txt")
f.close()
f.read()

"""Para simplificar, o resto dos exemplos nesta seção assumem que um objeto arquivo chamado f já foi criado.

Para ler o conteúdo de um arquivo, chame f.read(tamanho), que lê um punhado de dados devolvendo-os como uma string (em modo texto) ou bytes (em modo binário). tamanho é um argumento numérico opcional. Quando tamanho é omitido ou negativo, todo o conteúdo do arquivo é lido e devolvido; se o arquivo é duas vezes maior que memória da máquina, o problema é seu. Caso contrário, no máximo tamanho caracteres (em modo texto) ou tamanho bytes (em modo binário) são lidos e devolvidos. Se o fim do arquivo for atingido, f.read() devolve uma string vazia ('').
"""

f = open("usuarios.txt", "r")

f.read()

f.read()

f.close()

"""O método f.readline() lê uma única linha do arquivo; o caractere de quebra de linha (\n) é mantido ao final da string, e só é omitido na última linha do arquivo, se o arquivo não terminar com uma quebra de linha. Isso elimina a ambiguidade do valor retornado; se f.readline() retorna uma string vazia, o fim do arquivo foi atingido. Linhas em branco são representadas por um '\n' – uma string contendo apenas o caractere terminador de linha."""

f = open("usuarios.txt", "r")
print(f.readline())
print(f.readline())
print(f.readline())
print(f.readline())
print(f.readline())
print(f.readline())
print(f.readline())
print(f.readline())
f.close()

"""Uma maneira alternativa de ler linhas do arquivo é iterar diretamente pelo objeto arquivo. É eficiente, rápido e resulta em código mais simples:"""

f = open("usuarios.txt", "r")
for linha in f:
    print(linha.replace("\n", ""), end=" | ")
f.close()

f = open("usuarios.txt", "r")
print(f.readlines())
f.close()

"""Se desejar ler todas as linhas de um arquivo em uma lista, pode-se usar list(f) ou f.readlines().

f.write(string) escreve o conteúdo de string para o arquivo, retornando o número de caracteres escritos.
"""

with open("arquivo_teste.txt", "w") as f:
    print(f.write("Este é um teste\n"))

"""Outros tipos de objetos precisam ser convertidos – seja para uma string (em modo texto) ou para bytes (em modo binário) – antes de escrevê-los:"""

with open("arquivo_teste.txt", "a") as f:
    valor = ("resposta", 42)
    s = str(valor)
    print(f.write(s))

"""f.tell() retorna um inteiro dando a posição atual do objeto arquivo, no arquivo representado, como número de bytes desde o início do arquivo, no modo binário, e um número ininteligível, quando no modo de texto.

Para mudar a posição, use f.seek(offset, de_onde). A nova posição é computada pela soma do deslocamento offset a um ponto de referência especificado pelo argumento de-onde. Se o valor de de_onde é 0,a referência é o início do arquivo, 1 refere-se à posição atual, e 2 refere-se ao fim do arquivo. Este argumento pode ser omitido e o valor padrão é 0, usando o início do arquivo como referência.
"""

f = open("usuarios.txt", "r")

f.tell()

f.read()

f.tell()

f.seek(5)

f.read()

f.close()

"""---

**Exercício 13**

A ACME Inc., uma empresa de 500 funcionários, está tendo problemas de espaço em disco no seu servidor de arquivos. Para tentar resolver este problema, o Administrador de Rede precisa saber qual o espaço ocupado pelos usuários, e
identificar os usuários com maior espaço ocupado. Através de um programa, baixado da Internet, ele conseguiu gerar o seguinte arquivo, chamado

"usuarios.txt":

    alexandre       456123789
    anderson        1245698456
    antonio         123456456
    carlos          91257581
    cesar           987458
    rosemary        789456125

Neste arquivo, o nome do usuário possui 15 caracteres. A partir deste arquivo, você deve criar um programa que gere um relatório, chamado "relatório.txt", no seguinte formato:

    ACME Inc.               Uso do espaço em disco pelos usuários
    ------------------------------------------------------------------------
    Nr.  Usuário        Espaço utilizado     % do uso

    1    alexandre       434,99 MB             16,85%
    2    anderson       1187,99 MB             46,02%
    3    antonio         117,73 MB              4,56%
    4    carlos           87,03 MB              3,37%
    5    cesar             0,94 MB              0,04%
    6    rosemary        752,88 MB             29,16%

Espaço total ocupado: 2581,57 MB
Espaço médio ocupado: 430,26 MB

O arquivo de entrada deve ser lido uma única vez, e os dados armazenados em memória, caso sejam necessários, de forma a agilizar a execução do programa.
"""



#@title Resposta
usuarios = dict()

# abre o arquivo com os usuários
with open("usuarios.txt", "r") as arquivo:
    # começa a percorrer o condeúdo da linha
    for linha in arquivo:
        # obtém o usuário
        usuario = linha[:15].strip()

        # obtém o espaço utilizado
        espaco = int(linha[15:].strip())

        # adiciona ao dicionário
        usuarios[usuario] = espaco

# calcula o espaço total ocupado
espaco_total = sum(list(usuarios.values()))

# realiza a impressão dos resultados
print(
"""
ACME Inc.               Uso do espaço em disco pelos usuários
------------------------------------------------------------------------
Nr.  Usuário        Espaço utilizado     % do uso
"""
)

# percorre os usuários
n = 1
for u, e in usuarios.items():
    # adiciona o número do usuário
    output = f"{n}".ljust(5)

    # adiciona o nome do usuário
    output += f"{u}".ljust(15)

    # adiciona o espaço ocupado
    ocup = ("%.2f" % (e / (1024 ** 2))).rjust(8).replace(".", ",")
    ocup += " MB"
    output += ocup.ljust(21)

    # adiciona o % do disco ocupado
    output += ("%.2f%%" % (100 * e / espaco_total)).rjust(8).replace(".", ",")

    print(output)
    n += 1

"""---

## Projeto Final

Como parte de seu projeto final, vamos gerar as funções de um jogo de forca.

Utilize a estrutura abaixo e preencha as funções sem definição para fazer o jogo funcionar adequadamente.

Como parte do loop do jogo:
1. Carregue o arquivo palavras.txt para obter a lista de palavras possíveis
1. Sorteie uma palavra aleatória da lista acima
1. Imprima o estado da forca atual com os _ _ _ embaixo da forca com as letras a serem chutadas
1. Peça para o usuário chutar uma letra
1. Se a letra estiver correta substitua os _ onde ela aparece
1. Se estiver errada, imprima embaixo da forca as letras erradas e atualize o boneco
1. Caso o usuário perca, informe o número de chutes corretos e errados e a palavra correta
1. Caso o usuário ganhe, informe uma mensagem de sucesso
1. Ao final pergunte se o usuário quer jogar novamente

Lembre-se que a mesma letra não pode ser chutada novamente, e que não se pode colocar caracteres especiais ou com acento
"""

import random
import typing
import time
from IPython.display import clear_output


FORCAIMG = [
    """

      +---+
      |   |
          |
          |
          |
          |
    =========""",
    """

      +---+
      |   |
      O   |
          |
          |
          |
    =========""",
    """

      +---+
      |   |
      O   |
      |   |
          |
          |
    =========""",
    """

      +---+
      |   |
      O   |
     /|   |
          |
          |
    =========""",
    """

      +---+
      |   |
      O   |
     /|\  |
          |
          |
    =========""",
    """

      +---+
      |   |
      O   |
     /|\  |
     /    |
          |
    =========""",
    """

      +---+
      |   |
      O   |
     /|\  |
     / \  |
          |
    =========""",
]


def main():
    """
    Função Principal do programa
    """
    pass


def le_palavras() -> typing.List[str]:
    """
    Le arquivo com palavras que podem ser utilizadas
    como parte do jogo
    """
    pass


def gera_palavra_aleatoria(palavras: str) -> typing.List[str]:
    """
    Função que retorna uma string a partir da
    lista de palavras

    :param palavras: lista com palavras que podem ser sorteadas
    :return: palavra secreta do jogo
    """
    pass


def imprime_com_espacos(palavra: str) -> None:
    """
    Recebe uma string palavra ou lista e imprime essa com
    espaço entre suas letras ou strings

    :param palavra: palavra secreta do jogo
    """
    pass


def imprime_jogo(
    letras_erradas: typing.List[str],
    letras_acertadas: typing.List[str],
    palavra_secreta: str,
) -> None:
    """
    Feito a partir da variável global que contem as imagens
    do jogo em ASCII art, e támbem as letras chutadas de
    maneira correta e as letras erradas e a palavra secreta

    :param letras_erradas: lista de letras chutadas incorretamente
    :param letras_acertadas: lista de letras chutadas corretamente
    :param palavra_secreta: palavra secreta do jogo
    """
    pass


def recebe_palpite(palpites_feitos: typing.List[str]) -> str:
    """
    Função feita para garantir que o usuário coloque uma
    entrada válida, ou seja, que seja uma única letra
    que ele ainda não tenha chutado

    :param palpites_feitos: lista de letras chutadas anteriormente
    :return: nova letra chutada
    """
    pass


def jogar_novamente() -> bool:
    """
    Função que pede para o usuário decidir se ele quer
    jogar novamente e retorna um booleano representando
    a resposta

    :return: True se o jogador informou que deseja jogar novamente
    """
    return input("Você quer jogar novamente? (sim ou nao)\n").upper().startswith("S")


def verifica_se_ganhou(
    palavra_secreta: str, letras_acertadas: typing.List[str]
) -> bool:
    """
    Função que verifica se o usuário acertou todas as
    letras da palavra secreta

    :param palavra_secreta: palavra secreta do jogo
    :param letras_acertadas: lista de letras chutadas corretamente
    :return: booleano informando se o jogador ganhou o jogo
    """
    pass


main()

#@title Resposta
import random
import typing
import time
from IPython.display import clear_output


FORCAIMG = [
    """

      +---+
      |   |
          |
          |
          |
          |
    =========""",
    """

      +---+
      |   |
      O   |
          |
          |
          |
    =========""",
    """

      +---+
      |   |
      O   |
      |   |
          |
          |
    =========""",
    """

      +---+
      |   |
      O   |
     /|   |
          |
          |
    =========""",
    """

      +---+
      |   |
      O   |
     /|\  |
          |
          |
    =========""",
    """

      +---+
      |   |
      O   |
     /|\  |
     /    |
          |
    =========""",
    """

      +---+
      |   |
      O   |
     /|\  |
     / \  |
          |
    =========""",
]


def main():
    """
    Função Principal do programa
    """
    global FORCAIMG

    letras_erradas = list()
    letras_acertadas = list()

    # lista as palavras disponíveis para o jogo
    palavras = le_palavras()

    # seleciona uma palavra aleatória
    palavra_secreta = gera_palavra_aleatoria(palavras).upper()

    # cria o loop do jogo
    jogando = True
    while jogando:
        # imprime o estado do jogo atual
        clear_output(wait=True)
        time.sleep(0.3)
        imprime_jogo(letras_erradas, letras_acertadas, palavra_secreta)
        time.sleep(0.3)

        # recebe um palpite do jogador
        palpite = recebe_palpite(letras_erradas + letras_acertadas)

        # adiciona o palpite ao dicionário adequado
        if palpite in palavra_secreta:
            letras_acertadas.append(palpite)
        else:
            letras_erradas.append(palpite)

        # verifica se o usuário ganhou o jogo
        if verifica_se_ganhou(palavra_secreta, letras_acertadas):
            clear_output(wait=True)
            time.sleep(0.3)
            print("Exato! A palavra secreta é " + palavra_secreta + "! Você ganhou!!")
            jogando = False

        # verifica se o usuário perdeu o jogo
        elif len(letras_erradas) == len(FORCAIMG) - 1:
            clear_output(wait=True)
            time.sleep(0.3)
            print("Você excedeu o seu limite de palpites!")
            print(
                "Depois de "
                + str(len(letras_erradas))
                + " letras erradas e "
                + str(len(letras_acertadas)),
                end=" ",
            )
            print("palpites corretos, a palavra era " + palavra_secreta + ".")

            jogando = False

        # se o usuário terminar o jogo
        if not jogando:
            # pede para jogar novamente
            time.sleep(0.3)
            if jogar_novamente():
                letras_erradas = list()
                letras_acertadas = list()
                jogando = True
                palavra_secreta = gera_palavra_aleatoria(palavras).upper()


def le_palavras() -> typing.List[str]:
    """
    Le arquivo com palavras que podem ser utilizadas
    como parte do jogo
    """
    with open("palavras.txt") as f:
        return f.readlines()


def gera_palavra_aleatoria(palavras: str) -> typing.List[str]:
    """
    Função que retorna uma string a partir da
    lista de palavras

    :param palavras: lista com palavras que podem ser sorteadas
    :return: palavra secreta do jogo
    """
    return random.choice(palavras).replace("\n", "")


def imprime_com_espacos(palavra: str) -> None:
    """
    Recebe uma string palavra ou lista e imprime essa com
    espaço entre suas letras ou strings

    :param palavra: palavra secreta do jogo
    """
    for letra in palavra:
        print(letra, end=" ")
    print()


def imprime_jogo(
    letras_erradas: typing.List[str],
    letras_acertadas: typing.List[str],
    palavra_secreta: str,
) -> None:
    """
    Feito a partir da variável global que contem as imagens
    do jogo em ASCII art, e támbem as letras chutadas de
    maneira correta e as letras erradas e a palavra secreta

    :param letras_erradas: lista de letras chutadas incorretamente
    :param letras_acertadas: lista de letras chutadas corretamente
    :param palavra_secreta: palavra secreta do jogo
    """
    global FORCAIMG
    print(FORCAIMG[len(letras_erradas)] + "\n")

    print("Letras Erradas:", end=" ")
    imprime_com_espacos(letras_erradas)

    vazio = "_" * len(palavra_secreta)
    for i in range(len(palavra_secreta)):
        if palavra_secreta[i] in letras_acertadas:
            vazio = vazio[:i] + palavra_secreta[i] + vazio[i + 1 :]

    imprime_com_espacos(vazio)


def recebe_palpite(palpites_feitos: typing.List[str]) -> str:
    """
    Função feita para garantir que o usuário coloque uma
    entrada válida, ou seja, que seja uma única letra
    que ele ainda não tenha chutado

    :param palpites_feitos: lista de letras chutadas anteriormente
    :return: nova letra chutada
    """
    while True:
        palpite = input("Advinhe uma letra.\n").upper()

        if len(palpite) != 1:
            print("Coloque uma única letra.")
        elif palpite in palpites_feitos:
            print("Você já chutou esta letra. Escolha novamente.")
        elif not "A" <= palpite <= "Z":
            print("Por favor escolha apenas letras.")
        else:
            return palpite


def jogar_novamente() -> bool:
    """
    Função que pede para o usuário decidir se ele quer
    jogar novamente e retorna um booleano representando
    a resposta

    :return: True se o jogador informou que deseja jogar novamente
    """
    return input("Você quer jogar novamente? (sim ou nao)\n").upper().startswith("S")


def verifica_se_ganhou(
    palavra_secreta: str, letras_acertadas: typing.List[str]
) -> bool:
    """
    Função que verifica se o usuário acertou todas as
    letras da palavra secreta

    :param palavra_secreta: palavra secreta do jogo
    :param letras_acertadas: lista de letras chutadas corretamente
    :return: booleano informando se o jogador ganhou o jogo
    """
    return set(list(palavra_secreta)) == set(letras_acertadas)


main()

"""---"""